CTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>assign1</title>
<link rel=stylesheet
    href="/concepts/concepts.css" type="text/css" />
</head>
<body>
<font size="-1">
<div id="title">
<center>

<br/>
<span class="smaller">CS403: Programming Languages</span>
<br/>
<br/>
Assignment 1
<br/>

<br/>
<span class="smaller"><span class="smaller">
<a href="assign1.pdf">Printable Version</a>
</span></span>




<br/>
<div class="ldraw">
<image src="break-img-0-0.png">
</div>


</center>
</div>
<!-- SECTION_SEQUENCE -->
<!-- section -->
<h2>
 Preliminary information

<br/>
</h2><!-- QA_SEQUENCE -->

This is your first Scam assignment.
To run your code, use the following
command:
<br/>

<pre>
    scam assign1.scm
</pre>

At the top of your assignment, place a definition similar to the following:
<br/>

<pre>
    (define (author)
        (println &quot;AUTHOR: Rita Recursion rrita@crimson.ua.edu&quot;)
        )
</pre>

with the name and email replaced by your own name and email.
Define this function as well, to help with testing your code:
<br/>

<pre>
    (define (exprTest # $expr target)
        (define result (catch (eval $expr #)))
        (if (error? result)
            (println $expr &quot; is EXCEPTION: &quot; (result&#39;value)
                &quot; (it should be &quot; target &quot;)&quot;)
            (println $expr &quot; is &quot; result
                &quot; (it should be &quot; target &quot;)&quot;)
            )
        )
</pre>

For each numbered task (unless otherwise directed),
you are to provide a
function with a name of the form
<i>runN</i>,
with the <i>N</i> corresponding to the task number, starting at one
(as in <i>run1</i>,
<i>run2</i>,
etc.).
This
function is in addition to all other requested functions.
These <i>run</i>
functions will test your implementation and are to take
no arguments.
For example, if task 5 is:
<br/>
<span class="indent">
5. Implement factorial so that it implements a recursive process.
Name your function <i>fact</i>.
</span>

<br/>
you should provide a <i>run</i> function similar to:
<br/>

<pre>
    (define (run5)
        (exprTest (fact 0) 1)
        (exprTest (fact 3) 6)
        ...
        )
</pre>

<i>Woe betide students who
provide insufficient testing should their implementations prove to be
incorrect</i>!
If you do not complete an
exercise,
do not provide a <i>run</i> function for that
exercise.
If you omit the <i>run</i> function corresponding to
an exercise,
it will be assumed that you are skipping that
part
and you will receive no credit for that exercise.
<br/>
<br/>
When you have completed testing of your run functions, comment out
any calls to them (but do not comment out the definitions).
<br/>
<br/>
I will provide a test script which performs minimal testing of your
implementation.
If your program does not
pass the provided test script without failing,
I will not grade your exercise and you will receive zero credit for the
assignment. If your program passes the provided test script,
it will be graded with a more thorough set of tests.
<br/>
<br/>
It may be of use to know that you can have actual tabs and
newlines within a string, as in:
<br/>

<pre>
    (println &quot;
        The quick brown fox

               m
           u       p
        j             e
                        d

        over the lazy dog
    &quot;)
</pre>

which will print out as:
<br/>

<pre>

    The quick brown fox

           m
       u       p
    j             e
                    d

    over the lazy dog
</pre>

Another useful function for your <i>run</i> function is <i>inspect</i>. Here is an
example usage:
<br/>

<pre>
   (inspect (+ 2 3))
</pre>

which produces the output:
<br/>

<pre>
    (+ 2 3) is 5
</pre>

You may not use assignment (<i>assign</i> or <i>set!</i>)
in any of the code you write.
Nor may you use any looping function such as <i>while</i> or <i>for</i>.
<br/>
<!-- QA_SEQUENCE ENDED -->
<!-- section ENDED -->
<!-- section -->
<h2>
 Tasks
<br/>
</h2><!-- QA_SEQUENCE -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 -->
<!-- QA -->
<ol type="1" start="1">
<li>
 Explain why <i>if</i> and <i>my-if</i>
(defined below) can behave differently
for equivalent, legal inputs. Here is an example of equivalent calls to
<i>if</i> and <i>my-if</i> that behave exactly the same, in terms of output:
<br/>

<pre>
    (define x 2)
    (define a (readInt))
    (inspect (if (= a 0) x (/ a x)))
    (inspect (my-if (= a 0) x (/ a x)))
</pre>

where <i>my-if</i> is defined as
<br/>

<pre>
    (define (my-if a b c)
        (if (true? a)
            b
            c
            )
        )
</pre>

In particular,
give a concrete example in which the behavior is
different. You will need to come up with specific cases that show
this difference.
<br/>
<br/>
Your <i>run</i> function
should present this example and should explain precisely why the behavior is different.

<!-- ANSWER_SEQUENCE -->
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 -->
<!-- QA -->
<ol type="1" start="2">
<li>
 Define a function, named <i>zeno_cost</i>,
that computes the price of a ticket
for Zeno's Airlines given the distance <i>d</i> of the flight in
<i>stadia</i>, the cost <i>c</i> of the first half of the trip
in <i>drachma</i>,
and a factor <i>f</i> for computing the cost of the rest of the trip.
The total cost of a ticket is computed as follows:
<i>c</i> drachma for the
first half of the trip and
<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow> <mi>c</mi>  <mo>&times;</mo>    <mi>f</mi></mrow></math> drachma for the first half of the remaining half.
Of the part of the trip that still remains, the first half of
that is <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow> <mi>c</mi>  <mo>&times;</mo>    <mi>f</mi>  <mo>&times;</mo>    <mi>f</mi></mrow></math> drachma. Indeed, the first half of the
remaining portion is always <i>f</i> times the cost of the
previous portion.
<br/>
<br/>
If the distance to be traveled
is less than or equal to a daktylos (there are 9,600 daktylos to 1 stadion),
then the cost of traveling that distance a fixed cost of 7 drachma.
Otherwise,
if the cost of traveling half the distance to be
traveled
is less than or equal to a hemiobol
(one-twelfth of a drachma),
the cost of traveling the two halves is one hemibool.
<br/>
<br/>
Your <i>zeno_cost</i> function should implement a recursive process.
Expect real or integer numbers as arguments. Return the cost (a real number)
in drachma.

<!-- ANSWER_SEQUENCE -->
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 -->
<!-- QA -->
<ol type="1" start="3">
<li>
 The Mandelbrot set (for examples,
see
<a href="http://www.softlab.ece.ntua.gr/miscellaneous/mandel/mandel.html" style="font-size:10px,font-family:'Lucida Console',monospace">http://www.softlab.ece.ntua.gr/miscellaneous/mandel/mandel.html</a>
is a set of planar points,
a point
<code>(x,y)</code> being in the set if the
following iteration never diverges to infinity:
<br/>
<center>

<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow> <mi>r</mi>  <mo>=</mo>  <mi>r</mi>  <mo>&times;</mo>    <mi>r</mi>  <mo>-</mo>  <mi>s</mi>  <mo>&times;</mo> <mi>s</mi>   <mo>+</mo>  <mi>x</mi></mrow></math>
</center>

<br/>
and
<br/>
<center>

<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow> <mi>s</mi>  <mo>=</mo>  <mn>2</mn>  <mo>&times;</mo>    <mi>r</mi>  <mo>&times;</mo>    <mi>s</mi>  <mo>+</mo>  <mi>y</mi></mrow></math>
</center>

<br/>
with
<i>r</i> and <i>s</i> both starting out at 0.0.
While we can't iterate
forever to check for divergence,
there is a simple condition
which predicts divergence: if
<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow> <mi>r</mi>  <mo>&times;</mo>    <mi>r</mi>  <mo>+</mo>  <mi>s</mi>  <mo>&times;</mo>    <mi>s</mi>  <mo>&gt;</mo>    <mn>4</mn></mrow></math>
is ever true,
either <i>r</i>
or <i>s</i> will tend to diverge to
infinity.
Processing of a point continues until
divergence is detected or until some
threshold number of iterations has been
reached.
If the threshold is reached,
the point is considered to be in
the Mandelbrot set.
Obviously,
the higher the threshold,
the higher the confidence that the
point actually is in the set.
The points <i>not</i> in the Mandelbrot set can be categorized as to
their resistance to
divergence.
These points are often colorized, a point colored black
if it is in the set, red if it is very resistant to divergence,
blue if it immediately diverges, and somewhere in between
red and blue for intermediate resistance.
<br/>
<br/>
Define a function,
named <i>mandelbrot-iter</i>,
that takes a threshold as its single argument.
and returns another function that can be
used to test whether or not a point is in
the Mandelbrot set using the given threshold.
The returned function takes two arguments,
the x-coordinate,
and the y-coordinate of the point to be
tested and
it returns the resistance (i.e., the number of
iterations until the divergence test succeeds).
The return value should be
0 if the point described by the <i>x</i>- and <i>y</i>-coordinates
is in the Mandelbrot
set (i.e., reaches the threshold).
You should
test for divergence
before you
test for reaching the threshold.
<br/>
<br/>
Example usage:
<br/>

<pre>
    (define mandelbrot-tester (mandelbrot-iter 100))
    (if (= (mandelbrot-tester 2 3) 0)
        (print &quot;point (2,3) is in the Mandelbrot set!\n&quot;)
        (print &quot;point (2,3) is not in the Mandelbrot set.\n&quot;)
        )
</pre>

In the above example,
the threshold for determining
whether or not a number is in the Mandelbrot set
is 100.

<!-- ANSWER_SEQUENCE -->
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 -->
<!-- QA -->
<ol type="1" start="4">
<li>
 Define a function named <i>root3</i> which uses
a binary search algorithm to find the cube
root a given number. Your function should
return the current approximation
when the current approximation is
indistinguishable from the previous approximation.
Your function need only work for non-negative numbers.

<!-- ANSWER_SEQUENCE -->
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 -->
<!-- QA -->
<ol type="1" start="5">
<li>
 Define a function, named <i>crazyTriangle</i>, that prints out <i>n</i>
levels of
Pascal's triangle, but with a
twist. The leftmost and rightmost numbers at each level
are not necessarily ones, as with Pascal's triangle, but are given
as the first and second arguments.
The third argument is the number of levels to be printed.
The output produced by
<code>(crazyTriangle 1 1 6)</code> would be
Pascal's triangle:
<br/>

<pre>
         1
        1 1
       1 2 1
      1 3 3 1
     1 4 6 4 1
    1 5 10 10 5 1
</pre>

The output produced by
<code>(crazyTriangle 1 2 6)</code> would be
<br/>

<pre>
         1
        1 2
       1 3 2
      1 4 5 2
     1 5 9 7 2
    1 6 14 16 9 2
</pre>

Note that the apex is always the first argument.
<br/>
<br/>
Your function must print one level to a line with lower levels
above upper levels. Your levels need to be centered
around the apex (but don't worry if the triangle skews rightward
with multi-digit numbers).
Your function must also minimize any redundant computations and should
not overflow an integer <i>while computing a triangle entry</i> (unless the
entry itself overflows).

<!-- ANSWER_SEQUENCE -->
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 -->
<!-- QA -->
<ol type="1" start="6">
<li>
 Currying is the process of providing
the arguments to a function at different points
in time. The result of currying a function
is a new function that accepts the last of the remaining, unspecified
arguments. Define a function, named <i>oppy</i>,
that curries a mathematical expression of two binary operators.
As an example, these two expressions should evaluate
to the same result:
<br/>

<pre>
    (+ x (* y z))
    (((((oppy +) x) *) y) z)
</pre>

Note that <i>y</i> and <i>z</i> could be instantiated far later than <i>x</i>.
Your implementation will only be tested on expressions of the form given
above.

<!-- ANSWER_SEQUENCE -->
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 2 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 -->
<!-- QA -->
<ol type="1" start="7">
<li>
 The function <i>w</i>, described below, implements <i>Shank's</i> transform:
<br/>
<center>

<table>
<tr>
<td style="text-align:left";> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>   <mi>w</mi>  <mrow>      <mo form="prefix">(</mo>        <mi>f</mi>      <mo>,</mo>       <mi>i</mi>      <mo form="postfix">)</mo>   </mrow> <mo>=</mo>  <mi>f</mi>  <mrow>      <mo form="prefix">(</mo>        <mi>i</mi>      <mo form="postfix">)</mo>    </mrow></mrow></math> </td><td style="text-align:left";> if <i>i</i> is zero </td>
</tr>
<tr>
<td style="text-align:left";> <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>   <mi>w</mi>  <mrow>      <mo form="prefix">(</mo>        <mi>f</mi>      <mo>,</mo>       <mi>i</mi>      <mo form="postfix">)</mo>   </mrow> <mo>=</mo>  <mfrac linethickness="1">       <mrow>          <mi>S</mi>          <mrow>           <mo form="prefix">(</mo>                <mi>f</mi>              <mo>,</mo>              <mi>i</mi>              <mo>+</mo>              <mn>1</mn>              <mo form="postfix">)</mo>           </mrow>         <mo>&times;</mo>            <mi>S</mi>          <mrow>              <mo form="prefix">(</mo>          <mi>f</mi>              <mo>,</mo>              <mi>i</mi>              <mo>-</mo>              <mn>1</mn>              <mo form="postfix">)</mo>      </mrow>         <mo>-</mo>          <mi>S</mi>          <msup>              <mrow>                  <mo form="prefix">(</mo>                    <mi>f</mi>                  <mo>,</mo>                  <mi>i</mi>                  <mo form="postfix">)</mo>               </mrow>             <mn>2</mn>          </msup>        </mrow>     <mrow>          <mi>S</mi>          <mrow>              <mo form="prefix">(</mo>                <mi>f</mi>              <mo>,</mo>          <mi>i</mi>              <mo>+</mo>              <mn>1</mn>              <mo form="postfix">)</mo>           </mrow>         <mo>-</mo>          <mn>2</mn>           <mo>&times;</mo>            <mi>S</mi>          <mrow>              <mo form="prefix">(</mo>                <mi>f</mi>              <mo>,</mo>              <mi>i</mi>              <mo form="postfix">)</mo>           </mrow>         <mo>+</mo>          <mi>S</mi>          <mrow>              <mo form="prefix">(</mo>             <mi>f</mi>              <mo>,</mo>              <mi>i</mi>              <mo>-</mo>              <mn>1</mn>              <mo form="postfix">)</mo>            </mrow>     </mrow> </mfrac></mrow></math> </td><td style="text-align:left";> otherwise </td>
</tr>
</table>


</center>

<br/>
where the function <i>S</i> implements summation:
<br/>
<span class="indent">
<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow> <mi>S</mi>  <mrow>      <mo form="prefix">(</mo>        <mi>f</mi>      <mo>,</mo>      <mi>n</mi>      <mo form="postfix">)</mo>    </mrow> <mo>=</mo>  <mstyle displaystyle="true">        <munderover>            <mo>&sum;</mo>          <mrow>              <mi>i</mi>          <mo>=</mo>              <mn>0</mn>          </mrow>         <mi>n</mi>      </munderover>   </mstyle>   <mi>f</mi>  <mrow>      <mo form="prefix">(</mo>     <mi>i</mi>      <mo form="postfix">)</mo>   </mrow></mrow></math>
</span>

<br/>
Implement <i>w</i> and <i>S</i> using an iterative process with <i>no</i> redundant
computations.

<!-- ANSWER_SEQUENCE -->
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 -->
<!-- QA -->
<ol type="1" start="8">
<li>
 The ancient
Egyptians were perhaps the first people on earth to come up with the
idea of binary arithmetic when they developed their method of multiplication.
The Egyptian Multiplication method is a tabular calculation that lends
itself to a straightforward
computer implementation. The table starts out with a 1 in column <i>a</i>,
the multiplicand in column <i>b</i> and the multiplier in column <i>c</i>.
Columns <i>a</i> and <i>c</i> are successively doubled until the
value in column <i>a</i> is greater than the value in column <i>b</i>.
For example, to multiply 1960 by 56, we generate the following table:
<br/>
<center>

<table>
<tr>
<td style="text-align:right";> <i>a</i> </td><td style="text-align:right";> <i>b</i>&nbsp; </td><td style="text-align:right";> <i>c</i>&nbsp; </td>
</tr>
<tr>
<td style="text-align:right";> 1 </td><td style="text-align:right";> 56 </td><td style="text-align:right";> 1960</td>
</tr>
<tr>
<td style="text-align:right";> 2 </td><td style="text-align:right";> 56 </td><td style="text-align:right";> 3920</td>
</tr>
<tr>
<td style="text-align:right";> 4 </td><td style="text-align:right";> 56 </td><td style="text-align:right";> 7840</td>
</tr>
<tr>
<td style="text-align:right";> 8 </td><td style="text-align:right";> 56 </td><td style="text-align:right";> 15680</td>
</tr>
<tr>
<td style="text-align:right";> 16 </td><td style="text-align:right";> 56 </td><td style="text-align:right";> 31360</td>
</tr>
<tr>
<td style="text-align:right";> 32 </td><td style="text-align:right";> 56 </td><td style="text-align:right";> 62720</td>
</tr>
<tr>
<td style="text-align:right";> 64 </td><td style="text-align:right";> 56 </td><td style="text-align:right";> 125440</td>
</tr>
</table>


</center>

<br/>
At this point, we add a fourth column
initialized to zero and apply the following algorithm.
If the number
in column <i>a</i> is less than or equal to that of column <i>b</i>,
we
add column <i>c</i> to column <i>d</i> and subtract column <i>a</i>
from
column <i>b</i>.
Otherwise, we leave the values in <i>b</i> and <i>d</i>
unchanged.
In either case, we halve (integer division) the values
in both columns <i>a</i> and <i>c</i>.
We
stop when column <i>b</i> becomes zero. At this point, the
answer
resides in column <i>d</i>.
<br/>
<center>

<table>
<tr>
<td style="text-align:right";> <i>a</i> </td><td style="text-align:right";> <i>b</i>&nbsp; </td><td style="text-align:right";> <i>c</i>&nbsp; </td><td style="text-align:right";> <i>d</i> </td>
</tr>
<tr>
<td style="text-align:right";> 64 </td><td style="text-align:right";> 56 </td><td style="text-align:right";> 125440 </td><td style="text-align:right";> 0</td>
</tr>
<tr>
<td style="text-align:right";> 32 </td><td style="text-align:right";> 56 </td><td style="text-align:right";> 62720 </td><td style="text-align:right";> 0</td>
</tr>
<tr>
<td style="text-align:right";> 16 </td><td style="text-align:right";> 24 </td><td style="text-align:right";> 31360 </td><td style="text-align:right";> 62720</td>
</tr>
<tr>
<td style="text-align:right";> 8 </td><td style="text-align:right";> 8 </td><td style="text-align:right";> 15680 </td><td style="text-align:right";> 94080</td>
</tr>
<tr>
<td style="text-align:right";> 4 </td><td style="text-align:right";> 0 </td><td style="text-align:right";> 7840 </td><td style="text-align:right";> 109760</td>
</tr>
</table>


</center>

<br/>
Define a function named <i>egypt*</i> that takes two arguments,
the multiplicand and the multiplier and returns the product. Example call:
<br/>

<pre>
    (egypt* 56 1960) ;multiply 56 by 1960 (with no multiplication)
    (halve 56) ;divide 56 by 2 (with no division)
</pre>

Your method should
implement an iterative process for both <i>egypt*</i> and <i>halve</i>.
You may not use either multiplication
or division in your solution.
<br/>

<!-- ANSWER_SEQUENCE -->
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 -->
<!-- QA -->
<ol type="1" start="9">
<li>

Note: This problem is best viewed using the <a href="assign1.pdf">PDF version</a>.
<br/>

<br/>
Consider this infinite fraction:
<br/>
<center>

<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow> <mn>1</mn>  <mo>+</mo>  <mfrac linethickness="1">       <mn>1</mn>      <mrow>          <mn>1</mn>          <mo>+</mo>           <mfrac linethickness="1">               <mn>1</mn>              <mrow>                  <mn>2</mn>                  <mo>+</mo>               <mfrac linethickness="1">                      <mn>1</mn>                      <mrow>                          <mn>1</mn>                       <mo>+</mo>                         <mfrac linethickness="1">                               <mn>1</mn>                              <mrow>                                   <mn>2</mn>                                  <mo>+</mo>                                  <mfrac linethickness="1">                                   <mn>1</mn>                                      <mrow>                                          <mn>1</mn>                                      <mo>+</mo>                                          <mo>.</mo>                                          <mo>.</mo>                                      <mo>.</mo>                                      </mrow>                                 </mfrac>                           </mrow>                         </mfrac>                        </mrow>                 </mfrac>                </mrow>         </mfrac>     </mrow> </mfrac></mrow></math>
</center>

<br/>
Define a function called <i>mystery</i> that when given an integer
argument <i>n</i>, computes the value of this equation to
<i>n</i> terms.
<br/>
<br/>
For example, if <i>n</i> is 0, the function should return 1.
For <i>n</i> equal to 1, it should return <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>   <mn>1</mn>  <mo>+</mo>  <mfrac linethickness="1">       <mn>1</mn>      <mn>1</mn>  </mfrac></mrow></math> or 2.
For <i>n</i> equal to 2, it should return
<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow> <mn>1</mn>  <mo>+</mo>  <mfrac linethickness="1">       <mn>1</mn>      <mrow>          <mn>1</mn>          <mo>+</mo>           <mfrac linethickness="1">               <mn>1</mn>              <mn>2</mn>          </mfrac>        </mrow> </mfrac></mrow></math>
or
<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow> <mfrac linethickness="1">       <mn>5</mn>      <mn>3</mn>  </mfrac></mrow></math>. The return value should be cast to a real number.
Your function should compute its value using a recursive process.
<br/>
<br/>
Your <i>run</i> function should give the value of the equation with
an infinite number of terms.

<!-- ANSWER_SEQUENCE -->
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 1 items needed -->
<!-- selection array: 1 -->
<!-- QA -->
<ol type="1" start="10">
<li>

Note: This problem is best viewed using the <a href="assign1.pdf">PDF version</a>.
<br/>

<br/>
The famous Indian mathematician,
Ramanujan, asked a question that no one else seemed to be able to
solve: what is the value of:
<br/>
<center>

<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow> <msqrt>     <mrow>          <mn>1</mn>          <mo>+</mo>          <mn>2</mn>          <mo>&sdot;</mo>      <msqrt>             <mrow>                  <mn>1</mn>                  <mo>+</mo>                  <mn>3</mn>                  <mo>&sdot;</mo>              <msqrt>                     <mrow>                          <mn>1</mn>                          <mo>+</mo>                          <mn>4</mn>                      <mo>&sdot;</mo>                         <msqrt>                             <mrow>                                  <mn>1</mn>                              <mo>+</mo>                                  <mn>5</mn>                                  <mo>&sdot;</mo>                              <msqrt>                                     <mrow>                                          <mn>1</mn>                                      <mo>+</mo>                                          <mo>.</mo>                                          <mo>.</mo>                                      <mo>.</mo>                                      </mrow>                                 </msqrt>                           </mrow>                         </msqrt>                        </mrow>                 </msqrt>                </mrow>         </msqrt>     </mrow> </msqrt></mrow></math>
</center>

<br/>
carried out to infinity?
Instead of answering this question,
Ramanujan, gave a solution to the more general problem,
the value of:
<br/>
<center>

<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow> <msqrt>     <mrow>          <mn>1</mn>          <mo>+</mo>          <mi>x</mi>          <mo>&sdot;</mo>      <msqrt>             <mrow>                  <mn>1</mn>                  <mo>+</mo>                  <mrow>                      <mo form="prefix">(</mo>                  <mi>x</mi>                      <mo>+</mo>                      <mn>1</mn>                      <mo form="postfix">)</mo>                   </mrow>                  <mo>&sdot;</mo>                 <msqrt>                     <mrow>                          <mn>1</mn>                          <mo>+</mo>                          <mrow>                              <mo form="prefix">(</mo>                                <mi>x</mi>                              <mo>+</mo>                               <mn>2</mn>                              <mo form="postfix">)</mo>                           </mrow>                      <mo>&sdot;</mo>                           <msqrt>                             <mrow>                                  <mn>1</mn>                              <mo>+</mo>                                  <mrow>                                      <mo form="prefix">(</mo>                                  <mi>x</mi>                                      <mo>+</mo>                                      <mn>3</mn>                                  <mo form="postfix">)</mo>                                   </mrow>                                 <mo>&sdot;</mo>                              <msqrt>                                     <mrow>                                          <mn>1</mn>                                      <mo>+</mo>                                          <mo>.</mo>                                          <mo>.</mo>                                      <mo>.</mo>                                      </mrow>                                 </msqrt>                           </mrow>                         </msqrt>                        </mrow>                 </msqrt>                </mrow>         </msqrt>     </mrow> </msqrt></mrow></math>
</center>

<br/>
carried out to infinity.
Define a function,
named <i>ramanujan</i>,
which takes
as its two arguments the depth of a rational approximation to the above
nested expression (as before) and the value of <i>x</i>.
For example,
if the depth is 0 and <i>x</i> is 3,
<i>ramanujan</i> should
return 0.
If the depth is 1 and <i>x</i> is 3,
<i>ramanujan</i> should return
the value of <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>    <msqrt>     <mrow>          <mn>1</mn>          <mo>+</mo>          <mn>3</mn>      </mrow> </msqrt></mrow></math>
If the depth is 2 and <i>x</i> is 3,
the return value should be
the value of <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow>    <msqrt>     <mrow>          <mn>1</mn>          <mo>+</mo>          <mn>3</mn>          <mo>&sdot;</mo>          <msqrt>             <mrow>                  <mn>1</mn>                  <mo>+</mo>                  <mn>4</mn>              </mrow>      </msqrt>      </mrow> </msqrt></mrow></math>
Your function should implement
a recursive
process.
Define a second function, named <i>iramanujan</i>, with the same
semantics but implementing
an iterative
process.
<br/>
<br/>
Your <i>run</i> function should give the value
of the above expression in terms of <i>x</i>.

<!-- ANSWER_SEQUENCE -->
<!-- ANSWER_SEQUENCE ENDED -->
</li>
</ol>
<!-- QA ENDED -->
<!-- selection ENDED -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- selection -->

<!-- 1 questions in this selection -->
<!-- 0 items needed -->
<!-- QA_SEQUENCE ENDED -->
<!-- section ENDED -->
<!-- section -->
<h2>
 Assignment submission
<br/>
</h2><!-- QA_SEQUENCE -->

The entire assignment should be contained
in a single file named <i>assign1.scm</i>.
Any explanatory text should be in the form of Scam comments,
which
begin with a semicolon.
The file should load into the Scam
interpreter cleanly.
The last line of your file should be:
<br/>

<pre>
    (println &quot;assignment 1 loaded!&quot;)
</pre>

If you do not see the message "assignment 1 loaded" when
executing your file with the Scam interpreter,
then there is an error
somewhere that needs to be fixed.
If your file does not load properly (i.e.
I do not see the message),
you will receive no credit for your work.
<br/>
<br/>
To submit assignments, you need to install the <i>submit system</i>:
<br/>

<ul>

<li>

 <a href="linux.html">linux and cygwin instructions</a>
</li>

<li>

 <a href="mac.html">mac instructions</a>
</li>

</ul>


Now delete extraneous files from your working
directory.
Finally,
while in your working directory,
type the command:
<br/>

<pre>
    submit proglan lusth assign1
</pre>

The <i>submit</i> program will bundle up all the files in your current
directory and ship them to me.
Thus it is very important that only the files
related to the assignment
are in your directory
(you may submit
test cases and test scripts).
This includes subdirectories as well since
all the files in any subdirectories will also be shipped to me,
so be careful.
You may submit as many times as you want before the deadline; new
submissions replace old submissions.
<!-- QA_SEQUENCE ENDED -->
<!-- section ENDED -->
<!-- SECTION_SEQUENCE ENDED -->
</body>
</html>


