(define (pq)
	(define events nil)
	(define clock 0)
	(define (insert skip f)
		(define when (+ clock skip))
		(define (iter items)
			(cond
				((== items '()) (list (list when f))) ;can cons when and f together ;set-cdr! ;set-car!
				((< when (car (car items))) (cons (list when f) items))
				(else (cons (car items) (iter (cdr items))))
			)
		)
		(set! events (iter events))
	)
	(define (go) ;book calls this propogate
		(cond
			((== events '()) 'DONE)
			(else
				(define event (car events))
				(set! events (cdr events))
				(set! clock (car event))
				((cadr event))
				(go)
			)
		)
	)
	(define (peekClock)
		clock
	)
	(define (peekTime)
		(cond
			((== events '()) clock)
			(else
				(car (car events))
			)
		)
	)
	(define (peekFunction)
		(cond
			((== events '()) 'EMPTY)
			(else
				(cdr (car events))
			)
		)
	)
	this
)

(define q (pq))

(define (run-all items)
	(cond
		((== items '()) 'DONE)
		(else 
			((car items))
			(run-all (cdr items))
		)
	)
)

(define (wire)
	(define signal 0)
	(define endpoints '())
	(define (get)
		signal
	)
	(define (set v)
		(cond
			((!= v signal)
				(set! signal v)
				(run-all endpoints)
			)
		)
	)
	(define (add f)
		(set! endpoints (cons f endpoints))
		(f)
	)
	this
)

(define (and-gate in1 in2 out)
	(define delay 4)
	(define (action)
		(define inv1 ((in1'get)))
		(define inv2 ((in2'get)))
		((q'insert) delay 
			(lambda ()
				(if (or (= inv1 0) (= inv2 0))
					((out'set) 0)
					((out'set) 1)
				)
			)
		)
	)
	((in1'add) action)
	((in2'add) action)
)

(define (or-gate in1 in2 out)
	(define delay 4)
	(define (action)
		(define inv1 ((in1'get)))
		(define inv2 ((in2'get)))
		((q'insert) delay 
			(lambda ()
				(if (and (= inv1 0) (= inv2 0))
					((out'set) 0)
					((out'set) 1)
				)
			)
		)
	)
	((in1'add) action)
	((in2'add) action)
)

(define (not-gate in1 out)
	(define delay 2)
	(define (action)
		(define inv1 ((in1'get)))
		((q'insert) delay 
			(lambda ()
				(if (= inv1 1)
					((out'set) 0)
					((out'set) 1)
				)
			)
		)
	)
	((in1'add) action)
)

(define (probe w name)
	(define first #f)
	(define (action)
		(cond
			(first
				(set! first #f)
			)
			(else
				(println ((q'peekClock))": Wire " name " has a new value: " ((w'get)))
			)
		)
	)
	((w'add) action)
)

; (define (probe w name) ;if wanted to add delay to probe
	; (define (action)
		; (define delay)
		; ((q'insert) delay
			; (lambda ()
				; (println ((q'peekTime))": Wire " name " has a new value: " ((w'get)))
			; )
		; )
	; )
	; ((w'add) action)
; )

(define a (wire))
(define b (wire))
(define c (wire))
(define d (wire))

(define (xor-gate input1 input2 output)
	(define input1-not (wire))
	(not-gate input1 input1-not)
	(define input2-not (wire))
	(not-gate input2 input2-not)
	(define input1_AND_input2-not (wire))
	(and-gate input1 input2-not input1_AND_input2-not)
	(define input1-not_AND_input2 (wire))
	(and-gate input1-not input2 input1-not_AND_input2)
	(or-gate input1_AND_input2-not input1-not_AND_input2 output)
)

(define (fulladder input1 input2 carryin sum carryout)
	(define input2_XOR_carryin (wire))
	(xor-gate input2 carryin input2_XOR_carryin)
	(xor-gate input1 input2_XOR_carryin sum)
	(define input1_AND_input2 (wire))
	(and-gate input1 input2 input1_AND_input2)
	(define input1_AND_carryin (wire))
	(and-gate input1 carryin input1_AND_carryin)
	(define input2_AND_carryin (wire))
	(and-gate input2 carryin input2_AND_carryin)
	(define input1_AND_input2__OR__input1_AND_carryin (wire))
	(or-gate input1_AND_input2 input1_AND_carryin input1_AND_input2__OR__input1_AND_carryin)
	(or-gate input2_AND_carryin input1_AND_input2__OR__input1_AND_carryin carryout)
)

(define (fourbitadder inputs1 inputs2 outputs carry)
	(define carryin (wire))
	(define carryout1 (wire))
	(fulladder (cadddr inputs1) (cadddr inputs2) carryin (cadddr outputs) carryout1)
	(define carryout2 (wire))
	(fulladder (caddr inputs1) (caddr inputs2) carryout1 (caddr outputs) carryout2)
	(define carryout3 (wire))
	(fulladder (cadr inputs1) (cadr inputs2) carryout2 (cadr outputs) carryout3)
	(fulladder (car inputs1) (car inputs2) carryout3 (car outputs) carry)
)

; (define input1 (wire))
; (define input2 (wire))
; (define carryin (wire))
; (define sum (wire))
; (define carryout (wire))
; (probe input1 'input1)
; (probe input2 'input2)
; (probe carryin 'carryin)
; (probe sum 'sum)
; (probe carryout 'carryout)
; (fulladder input1 input2 carryin sum carryout)
; ((input1'set) 1)
; ((input2'set) 1)
; ((carryin'set) 1)

(define inputs1 (list (wire) (wire) (wire) (wire)))
(define inputs2 (list (wire) (wire) (wire) (wire)))
(define outputs (list (wire) (wire) (wire) (wire)))
(define carry (wire))
(probe (cadddr outputs) 'bit1)
(probe (caddr outputs) 'bit2)
(probe (cadr outputs) 'bit3)
(probe (car outputs) 'bit4)
(probe carry 'carry)

(fourbitadder inputs1 inputs2 outputs carry)

(((cadddr inputs1)'set) 0)
(((caddr inputs1)'set) 1)
(((cadr inputs1)'set) 1)
(((car inputs1)'set) 0)

(((cadddr inputs2)'set) 1)
(((caddr inputs2)'set) 1)
(((cadr inputs2)'set) 0)
(((car inputs2)'set) 0)

;(probe a 'a)
;(probe b 'b)
;(probe c 'c)
;(probe d 'd)

;(and-gate a b c)
;(not-gate c d)
;((a'set) 1)
;((b'set) 1)

((q'go))
(println "Result is: " ((carry'get)) (((car outputs)'get)) (((cadr outputs)'get)) (((caddr outputs)'get)) (((cadddr outputs)'get)))
