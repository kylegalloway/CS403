func front_ptr(queue)
{
    return car(queue);
}
func rear_ptr(queue)
{
    return cdr(queue);
}
func set_front_ptr(queue, item)
{
    set_car(queue, item);
}
func set_rear_ptr(queue, item)
{
    set_cdr(queue, item);
}

func empty_queue?(queue)
{
    return (null?(front_ptr(queue)));
}

func make_queue()
{
    cons(nil, nil);
}

func front_queue(queue)
{
    if (empty_queue?(queue))
    {
        return error("FRONT called with an empty queue", queue);
    }
    else
    {
        return car(front_ptr(queue));
    }
}

func insert_queue(queue item)
{
    var new_pair = cons(item, nil);
    if(empty_queue?(queue))
    {
        set_front_ptr(queue, new_pair);
        set_rear_ptr(queue, new_pair);
        return queue;
    }
    else
    {
        set_cdr(rear_ptr(queue), new_pair);
        set_rear_ptr(queue, new_pair);
        return queue;
    }
}

func delete_queue(queue)
{
    if(empty_queue?(queue))
    {
        return error("DELETE called with an empty queue", queue);
    }
    else
    {
        set_front_ptr(queue, (cdr(front_ptr(queue))));
        return queue;
    }
}

func apply(f, L, size)
{
    var x = L[0];
    while (x = L[size])
    {
        f(L[x]);
        var x = L[x + 1];
    }
    return "DONE";
}

func error(L)
{
    return apply(println, L, 2);
}

func make_wire()
{
    var signal_value = 0;
    var action_procedures = [];

    func set_my_signal(new_value)
    {
        if(signal_value != new_value)
        {
            set(signal_value, new_value);
            return call_each(action_procedures);
        }
        else
        {
            return "DONE";
        }
    }

    func accept_action_procedure(proc)
    {
        set(action_procedures, cons(proc, action_procedures));
        return proc();
    }

    func dispatch(m)
    {
        if (m == "'get_signal") { return signal_value; }
        else if (m == "'set_signal") { return set_my_signal; }
        else if (m == "'add_action") { return accept_action_procedure; }
        else { return error("Unknown operation __ WIRE", m); }
    }

    return dispatch;

}

func call_each(procedures)
{
    if (null?(procedures))
    {
        return "DONE";
    }
    else
    {
        car(procedures)();
        return call_each(cdr(procedures));
    }
}

func get_signal(wire) { return wire("'get_signal"); }

func set_signal(wire, new_value)
{
    return wire("'set_signal")(new_value);
}

func add_action(wire, action_procedure)
{
    return wire("'add_action")(action_procedure);
}

func after_delay(delay, action)
{
    return add_to_agenda((delay + current_time(the_agenda)), action, the_agenda);
}

func propagate()
    if (empty_agenda? (the_agenda))
    {
        return "DONE";
    }
    else
    {
        var first_item = first_agenda_item(the_agenda);
        first_item();
        remove_first-agenda_item(the_agenda);
        return propogate();
    }
}

func make_time_segment(time, queue) { return cons(time, queue); }

func segment_time(s) { return car(s); }

func segment_queue(s) { return cdr(s); }

func make_agenda() { return [0]; }

func empty_agenda?(agenda) { return null?(segments (agenda)); }

func first_agenda_item (agenda)
{
    if (empty_agenda? (agenda))
    {
        return error ("Agenda is empty __ FIRST_AGENDA_ITEM", nil);

    }
    else
    {
        var first_seg = first_segment(agenda);
        set_current_time(agenda, segment_time(first_seg));
        return front_queue(segment_queue(first_seg));
    }
}

func remove_first_agenda_item(agenda)
{
    var q = segment_queue(first_segment(agenda));
    delete_queue(q);
    if(empty_queue?(q))
    {
        return set_segments(agenda, rest_segments(agenda));
    }
}

func add_to_agenda(time, action, agenda)
{
    func belongs_before?(segments)
    {
        if (null?(segments)) { return true; }
        if (time < segment_time(car(segments))) { return true; }
    }

    func make_new_time_segment(time, action)
    {
        var q = make_queue();
        insert_queue(q, action);
        return make_time_segment(time, q);
    }

    func add_to_segments(segments)
    {
        if(segment_time(car(segments)) == time)
        {
            return insert_queue(segment_queue(car(segments)), action);
        }
        else
        {
            var rest = cdr(segments);
            if (belongs_before?(rest))
            {
                set_cdr(
                    segments,
                    cons(
                        make_new_time_segment(time, action),
                        cdr(segments)
                        )
                    )
                return add_to_segments(rest);
            }
        }
    }

    var segs = segments(agenda);
    if(belongs_before?(segs))
    {
        if(null?(segs))
        {
            return set_segments(agenda, [make_new_time_segment(time, action)]);
        }
        else
        {
            return set_segments(agends, cons(make_new_time_segment(time, action), cdr(segs)));
        }
    }
    else
    {
        return add_to_segments(segs);
    }
}

func current_time(agenda) { return car (agenda); }

func set_current_time(agenda, time) { return set_car(agenda, time); }

func segments(agenda) { return cdr(agenda); }

func set_segments(agenda, segments) { return set_cdr(agenda, segments); }

func first_segment(agenda) { return car(segments(agenda)); }

func rest_segments(agenda) { return cdr(segments(agenda)); }

###############################################################################
## STOPPED HERE
###############################################################################
#$

func (and_gate a1 a2 output)
    func (and_action_procedure)
        (let ((new_value
                (logical_and (get_signal a1) (get_signal a2))))
             (after_delay and_delay
                         (lambda ()
                            (set_signal output new_value)
                         )
             )
        )
    )
    (add_action a1 and_action_procedure)
    (add_action a2 and_action_procedure)
    'ok
)

func (logical_and a1 a2)
    (cond
        ((and (= a1 1) (= a2 1)) 1)
        (else 0)
    )
)

func (or_gate o1 o2 output)
    func (or_action_procedure)
        (let ((new_value
                (logical_or (get_signal o1) (get_signal o2))))
             (after_delay or_delay
                         (lambda ()
                            (set_signal output new_value)
                         )
             )
        )
    )
    (add_action o1 or_action_procedure)
    (add_action o2 or_action_procedure)
    'ok
)

func (logical_or o1 o2)
    (cond
        ((= o1 1) 1)
        ((= o2 1) 1)
        (else 0)
    )
)

func (inverter input output)
    func (invert_input)
        (let ((new_value (logical_not (get_signal input))))
             (after_delay inverter_delay
                          (lambda ()
                            (set_signal output new_value)
                          )
             )
        )
    )
    (add_action input invert_input)
    'ok
)

func (logical_not s)
    (cond ((= s 0) 1)
          ((= s 1) 0)
          (else (error "Invalid signal" s))
    )
)

func (add1 a b c_in sum c_out)
    func s (make_wire))
    func c1 (make_wire))
    func c2 (make_wire))
    func w (make_wire))
    func x (make_wire))
    func y (make_wire))
    func z (make_wire))

    ; First half_adder
    ; (half_adder b c_in s c1)
    (or_gate b c_in w)
    (and_gate b c_in c1)
    (inverter c1 x)
    (and_gate w x s)

    ; Second half_adder
    ; (half_adder a s sum c2)
    (or_gate a s y)
    (and_gate a s c2)
    (inverter c2 z)
    (and_gate y z sum)


    (or_gate c1 c2 c_out)
    'ok
)

func (add4 X Y O c_out)
    func c_in (make_wire))
    func c1 (make_wire))
    func c2 (make_wire))
    func c3 (make_wire))

    func x0 (car X))
    func x1 (cadr X))
    func x2 (caddr X))
    func x3 (cadddr X))
    func y0 (car Y))
    func y1 (cadr Y))
    func y2 (caddr Y))
    func y3 (cadddr Y))
    func o0 (car O))
    func o1 (cadr O))
    func o2 (caddr O))
    func o3 (cadddr O))


    ; add1 definition
    ; (add1 a b c_in sum c_out)
    (add1 x3 y3 c_in o3 c1)
    (add1 x2 y2 c1 o2 c2)
    (add1 x1 y1 c2 o1 c3)
    (add1 x0 y0 c3 o0 c_out)
)

func the_agenda nil)
func and_delay 0)
func or_delay 0)
func inverter_delay 0)

func (run4)
    (set the_agenda (make_agenda))
    (set and_delay 5)
    (set or_delay 3)
    (set inverter_delay 1)

    func x0 (make_wire))
    func x1 (make_wire))
    func x2 (make_wire))
    func x3 (make_wire))
    func y0 (make_wire))
    func y1 (make_wire))
    func y2 (make_wire))
    func y3 (make_wire))
    func o0 (make_wire))
    func o1 (make_wire))
    func o2 (make_wire))
    func o3 (make_wire))
    func carry (make_wire))
    (inspect (add4
        (list x3 x2 x1 x0)
        (list y3 y2 y1 y0)
        (list o3 o2 o1 o0)
        carry
        )
    )
    (set_signal x0 0)
    (set_signal x1 1)
    (set_signal x2 1)
    (set_signal x3 1)
    (propagate)
    (println "X        = 0"(get_signal x3) (get_signal x2) (get_signal x1) (get_signal x0))
    (println "Y        = 0"(get_signal y3) (get_signal y2) (get_signal y1) (get_signal y0))
    (println "Result is: " (get_signal carry) (get_signal o3) (get_signal o2) (get_signal o1) (get_signal o0))
    (set_signal y0 0)
    (set_signal y1 0)
    (set_signal y2 0)
    (set_signal y3 0)
    (propagate)
    (println "X        = 0"(get_signal x3) (get_signal x2) (get_signal x1) (get_signal x0))
    (println "Y        = 0"(get_signal y3) (get_signal y2) (get_signal y1) (get_signal y0))
    (println "Result is: " (get_signal carry) (get_signal o3) (get_signal o2) (get_signal o1) (get_signal o0))