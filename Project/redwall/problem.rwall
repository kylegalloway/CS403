func printArray(arr)
{
    var l = length(arr);
    var i = 0;
    while(i < l)
    {
        print(arr[i]);
        var i =  i + 1;
    }
}

func cons(a, b)
{
    return [a, b];
}

func car(lyst)
{
    if(lyst == nil)
    {
        print();
        print();
        print("Cannot take car of nil. Exiting");
        print();
        print();
        return lyst[0];
    }
    return lyst[0];
}

func cdr(lyst)
{
    return lyst[1];
}

func setCar(lyst, val)
{
    lyst[0] = val;
    return con;
}
func setCdr(lyst,val)
{
    lyst[1] = val;
    return con;
}
func isNull(lyst)
{
    if(lyst == nil)
    {
        return true;
    }
    else
    {
        return false;
    }
}

func arrConsTest()
{
    print("Storing arr1 = [1,2]");
    var arr1 = [1, 2];
    var a = arr1[0];
    var b = arr1[1];
    print("arr1[0] should be: 1");
    print(a);
    print("arr1[1] should be: 2");
    print(b);
    var arr2 = cons(1, cons(2, nil));
    print("car(arr2) == arr2[0] == 1");
    print(car(arr2));
    print(arr2[0]);
    print("cdr(arr2) == arr2[1] == Lexeme");
    print(cdr(arr2));
    print(arr2[1]);
    print("Storing arr3 = cdr(arr2)");
    var arr3 = cdr(arr2);
    print("Storing arr4 = arr2[1]");
    var arr4 = arr2[1];
    print("car(arr3) == arr3[0] == car(arr4) == arr4[0] == 2");
    print(car(arr3));
    print(arr3[0]);
    print(car(arr4));
    print(arr4[0]);
    print("cdr(arr3) == arr3[1] == cdr(arr4) == arr4[1] == nil");
    print(cdr(arr3));
    print(arr3[1]);
    print(cdr(arr4));
    print(arr4[1]);
    print("Is car arr4 null?");
    print(isNull(arr4[0]));
    print("Is cdr arr4 null?");
    print(isNull(arr4[1]));
}

func frontPtr(queue){return car(queue)}
func rearPtr(queue){return cdr(queue)}
func setFrontPtr(queue, item){return setCar(queue, item)}
func setRearPtr(queue, item){return setCdr(queue, item)}
func isEmptyQueue(queue){return isNull(frontPtr(queue))}
func makeQueue(){return cons(nil, nil)} ~~Trace this for accuracy
func frontQueue(queue)
{
	if(isEmptyQueue(queue))
	{
		print()print()
		print("FRONT called with an empty queue. Exiting")
		return car(frontPtr(queue))
	}
	else
	{
		return car(frontPtr(queue))
	}
}
func insertQueue(queue, item)
{
	var new_pair = cons(item, nil)

	if(isEmptyQueue(queue))
	{
		setFrontPtr(queue, new_pair)
		setRearPtr(queue, new_pair)
		return queue
	}
	else
	{
		setCdr(rearPtr(queue), new_pair)
		setRearPtr(queue, new_pair)
		return queue
	}
}
func deleteQueue(queue)
{
	if(isEmptyQueue(queue))
	{
		print()print()
		print("DELETE called with an empty queue. Exiting")
		return car(frontPtr(queue))
	}
	else
	{
		setFrontPtr(queue, cdr(frontPtr(queue)))
		return queue
	}
}

~~~~~~~~~~
~ Agenda
~~~~~~~~~~
func makeSegment(time, queue)
{
	return cons(time, queue)
}

func segmentTime(seg)
{
	return car(seg)
}

func segmentQueue(seg)
{
	return cdr(seg)
}

func makeAgenda()
{
	return cons(0, nil)
}

func currentTime(agenda)
{
	return car(agenda)
}

func setCurrentTime(agenda, time)
{
	return setCar(agenda, time)
}

func segments(agenda)
{
	return cdr(agenda)
}

func setSegments(agenda, segments)
{
	return setCdr(agenda, segments)
}

func firstSegment(agenda)
{
	return car(segments(agenda))
}

func restSegments(agenda)
{
	return cdr(segments(agenda))
}

func emptyAgenda(agenda)
{
	return isNull(segments(agenda))
}

func addToAgenda(time, action, agenda)
{
	func doesBelongBefore(segments)
	{
		if(isNull(segments))
		{
			return 1
		}
		else if (time < segmentTime(car(segments)))
		{
			return 1
		}
		else
		{
			return 0
		}
	}
	func makeNewTimeSegment(time, action)
	{
		var q = makeQueue()
		insertQueue(q, action)
		return makeSegment(time, q)
	}
	func addToSegments(segments)
	{
		if(segmentTime(car(segments)) == time)
		{
			return insertQueue(segmentQueue(car(segments)),action)
		}
		else
		{
			var rest = cdr(segments)
			if(doesBelongBefore(rest))
			{
				return setCdr(segments, cons(makeNewTimeSegment(time, action), cdr(segments)))
			}
			else
			{
				return addToSegments(rest)
			}
		}
	}
	var segments = segments(agenda)
	if(doesBelongBefore(segments))
	{
		return setSegments(agenda,
					cons(makeNewTimeSegment(time,action), segments)
					)
	}
	else
	{
		return addToSegments(segments)
	}
}
func removeFirstAgendaItem(agenda)
{
	var q = segmentQueue(firstSegment(agenda))
	deleteQueue(q)
	if(isEmptyQueue(q))
	{
		return setSegments(agenda, restSegments(agenda))
	}
}
func firstAgendaItem(agenda)
{
	if(emptyAgenda(agenda))
	{
		print()print()
		print("EMPTY AGENDA")
		print()print()
	}
	else
	{
		var first_seg = firstSegment(agenda)
		setCurrentTime(agenda, segmentTime(first_seg))
		return frontQueue(segmentQueue(first_seg))
	}
}

~~~~~~~~~~~~~~~~~~~~
~ Circuit Initialize
~~~~~~~~~~~~~~~~~~~~
var the_agenda = makeAgenda()
var and_gate_delay = 3
var or_gate_delay = 3
var inverter_delay = 2

~~~~~~~~~~~~~~
~ After-Delay
~~~~~~~~~~~~~~
func afterDelay(mdelay, action)
{
	return addToAgenda((mdelay + currentTime(the_agenda)), action, the_agenda)
}

~~~~~~~~~~~~~~
~ Propagate
~~~~~~~~~~~~~~
func propagate()
{
	if(emptyAgenda(the_agenda))
	{
		return "done"
	}
	else
	{
		var first_item = firstAgendaItem(the_agenda)
		first_item()
		removeFirstAgendaItem(the_agenda)
		propagate()
	}
}

~~~~~~~~~~~~~
~ Wire Stuff
~~~~~~~~~~~~~
func makeWire()
{
	var signal = 0
	var action_procedures = nil

	func setMySignal(val)
	{
		if(signal != val)
		{
			signal = val
			return callEach(action_procedures)
		}
		else
		{
			return "done"
		}
	}
	func acceptActionProcedure(proc)
	{
		action_procedures = cons(proc, action_procedures)
		return proc()
	}

	func dispatch(m)
	{
		if(m == "get-signal") {return signal}
		else if(m == "set-signal") {return setMySignal}
		else if(m == "add-action") {return acceptActionProcedure}
		else {print("Unknown Operation --WIRE ", m)}
	}
	return dispatch
}
func callEach(procedures)
{
	if(isNull(procedures))
	{
		return "done"
	}
	else
	{
		var temp = car(procedures)
		temp()
		return callEach(cdr(procedures))
	}
}
func setSignal(wire, value)
{
	var temp = wire("set-signal")
	temp(value)
}
func getSignal(wire)
{
	return wire("get-signal")
}
func addAction(wire, ap)
{
	var temp = wire("add-action")
	temp(ap)
}

func inverter(in, out)
{
	func invertInput()
	{
		var inv =
			lambda(s)
			{
				if(s == 0){return 1}
				else if(s == 1){return 0}
				else{print("ERROR! Incorrect signal value in INVERTER")}
			}

		var val = inv(getSignal(in))
		return afterDelay(inverter_delay,
				   lambda(){setSignal(out, val)})

	}
	addAction(in, invertInput)
	return "ok"
}
func orGate(in1, in2, out)
{
	func orActionProcedure()
	{
		var ort =
			lambda()
			{
				var v1 = getSignal(in1)
				var v2 = getSignal(in2)
				if((v1 == 0) && (v2 == 0))
				{
					return 0
				}
				else {return 1}
			}
		var v = ort()
		return afterDelay(or_gate_delay,
				   lambda(){setSignal(out, v)})
	}
	addAction(in1, orActionProcedure)
	addAction(in2, orActionProcedure)
	return "ok"
}
func andGate(in1, in2, out)
{
	func andActionProcedure()
	{
		var ant =
			lambda()
			{
				var v1 = getSignal(in1)
				var v2 = getSignal(in2)
				if((v1 == 0) || (v2 == 0)) {return 0}
				else {return 1}
			}
		var v = ant()
		return afterDelay(and_gate_delay,
				   lambda(){setSignal(out, v)})
	}
	addAction(in1, andActionProcedure)
	addAction(in2, andActionProcedure)
	return "ok"
}
func halfAdder(in1, in2, out, cout)
{
	var x = makeWire()
	var y = makeWire()
	orGate(in1, in2, x)
	andGate(in1, in2, cout)
	inverter(cout, y)
	andGate(x, y, out)
	return "ok"
}
func fullAdder(in1, in2, out, cin, cout)
{
	var x = makeWire()
	var y = makeWire()
	var z = makeWire()
	halfAdder(in2, cin, x, z)
	halfAdder(in1, x, out, y)
	orGate(y, z, cout)
	return "ok"
}
func probe(name, wire)
{
	addAction(wire,
			  lambda()
			  {
			  	print(name," ",currentTime(the_agenda), " New-value = ",getSignal(wire))
			  }
		)
}

~~~~~~~~~~~~~~~~~~~~
~ Program Execution
~~~~~~~~~~~~~~~~~~~~
var a = makeWire()
var b = makeWire()
var carryin = makeWire()
var carryout = makeWire()
var result = makeWire()
~orGate(a,b,result)
fullAdder(a, b, result, carryin, carryout)
func addBiNums(val1, val2, cin)
{
	print()
	print("A: ",val1," B: ",val2," Cin: ",cin)
	setSignal(a, val1)
	setSignal(b, val2)
	setSignal(carryin, cin)
	propagate()
}
probe("Wire A",a)
probe("Wire B",b)
probe("CarryIn", carryin)
probe("CarryOut", carryout)
probe("Output",result)
propagate()
addBiNums(0, 0, 0)
addBiNums(1, 0, 0)
addBiNums(0, 1, 0)
addBiNums(1, 1, 0)
addBiNums(0, 0, 1)
addBiNums(1, 0, 1)
addBiNums(0, 1, 1)
addBiNums(1, 1, 1)